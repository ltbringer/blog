<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[ltbringer/blog]]></title><description><![CDATA[Programming|Art|Readings|Experiments.]]></description><link>https://ltbringer.github.io/blog/</link><image><url>https://ltbringer.github.io/blog//logos/logo-48.png</url><title>ltbringer/blog</title><link>https://ltbringer.github.io/blog/</link></image><generator>GatsbyJS Advanced Starter</generator><lastBuildDate>Sun, 19 Apr 2020 19:31:43 GMT</lastBuildDate><atom:link href="https://ltbringer.github.io/blog//rss.xml" rel="self" type="application/rss+xml"/><copyright><![CDATA[Copyright © 2020. All rights reserved.]]></copyright><item><title><![CDATA[Thread Communication simulation]]></title><description><![CDATA[Setup Let's say we have:  A buffer of limited size. A couple of producers. A couple of consumers. What happens when producers try to fill…]]></description><link>https://ltbringer.github.io/blog//thread-communication-simulation</link><guid isPermaLink="false">https://ltbringer.github.io/blog//thread-communication-simulation</guid><category><![CDATA[scala]]></category><category><![CDATA[parallel]]></category><pubDate>Sun, 19 Apr 2020 18:30:00 GMT</pubDate><content:encoded>&lt;h1 id=&quot;setup&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#setup&quot; aria-label=&quot;setup permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Setup&lt;/h1&gt;
&lt;p&gt;Let&apos;s say we have: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A buffer of limited size.&lt;/li&gt;
&lt;li&gt;A couple of producers.&lt;/li&gt;
&lt;li&gt;A couple of consumers.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;What happens when producers try to fill the buffer while consumers are simultaneously trying to read the buffer. We want to understand &lt;code class=&quot;language-text&quot;&gt;deadlocks&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;livelocks&lt;/code&gt; and what should be done for a normal operation.&lt;/p&gt;
&lt;iframe height=&quot;900px&quot; width=&quot;100%&quot; src=&quot;https://repl.it/@amreshvenugopal/DemandingQuestionablePhp?lite=true&quot; scrolling=&quot;no&quot; frameborder=&quot;no&quot; allowtransparency=&quot;true&quot; allowfullscreen=&quot;true&quot; sandbox=&quot;allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals&quot;&gt;&lt;/iframe&gt;
&lt;p&gt;The detail is in the wait over &lt;code class=&quot;language-text&quot;&gt;while(buffer.isEmpty)&lt;/code&gt; in the implementation of &lt;code class=&quot;language-text&quot;&gt;Consumer&lt;/code&gt; so if the current &lt;code class=&quot;language-text&quot;&gt;thread&lt;/code&gt; is active, and &lt;code class=&quot;language-text&quot;&gt;buffer&lt;/code&gt; is not empty, only then is a &lt;code class=&quot;language-text&quot;&gt;consumer&lt;/code&gt; allowed to read off the &lt;code class=&quot;language-text&quot;&gt;buffer&lt;/code&gt;.&lt;/p&gt;</content:encoded><author>oilyfood@protonmail.com</author></item></channel></rss>