{"componentChunkName":"component---src-templates-post-js","path":"/sicp-exercises-1-6","result":{"data":{"markdownRemark":{"html":"<p>This is a series of posts related to SICP exercises, in continuation of a <a href=\"https://ltbringer.github.io/blog/sicp-exercises-1-0-1-5\">previous post</a>.</p>\n<p>The chapters that lead to the exercises are:</p>\n<ol>\n<li>\n<p>Building Abstractions with Procedures</p>\n<ol>\n<li>\n<p>The elments of programming.</p>\n<ol start=\"7\">\n<li>Example: Square Roots by Newton's method (1 - 6 covered in previous post)</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p>The chapter starts with a case for calculating square roots.</p>\n<span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msqrt><mi>x</mi></msqrt><mo>=</mo><mi>y</mi><mo separator=\"true\">;</mo><mtext> such that </mtext><mi>y</mi><mo>≥</mo><mn>0</mn><mtext> and </mtext><msup><mi>y</mi><mn>2</mn></msup><mo>=</mo><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">\\sqrt{x} = y; \\text{ such that } y \\geq 0 \\text{ and } y^2 = x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.04em;vertical-align:-0.190845em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491550000000001em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord mathdefault\">x</span></span></span><span style=\"top:-2.809155em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.190845em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord text\"><span class=\"mord\"> such that </span></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0585479999999998em;vertical-align:-0.19444em;\"></span><span class=\"mord\">0</span><span class=\"mord text\"><span class=\"mord\"> and </span></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span></span>\n<blockquote>\n<p>The most common way is to use Newton’s method of successive approximations, which says that\nwhenever we have a guess y for the value of the square root of a number x , we can perform a\nsimple manipulation to get a better guess (one closer to the actual square root) by\naveraging y with x/y.</p>\n</blockquote>\n<p>Example:</p>\n<table>\n<thead>\n<tr>\n<th>Guess</th>\n<th>Quotient</th>\n<th>Average</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>(2/1) = 2</td>\n<td>((2 + 1) / 2) = 1.5</td>\n</tr>\n<tr>\n<td>1.5</td>\n<td>(2/1.5) = 1.3333</td>\n<td>((1.33 + 1.5)/2) = 1.41</td>\n</tr>\n<tr>\n<td>1.416</td>\n<td>(2/1.4167) = 1.4118</td>\n<td>((1.4167 + 1.4118)/2) = 1.4142</td>\n</tr>\n<tr>\n<td>1.4142</td>\n<td>...</td>\n<td>...</td>\n</tr>\n</tbody>\n</table>\n<p>Using the above, we get to the following strategy:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token comment\">;; Missing procedures will be created later.</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">sqrt-iter</span> guess x<span class=\"token punctuation\">)</span> \n  <span class=\"token punctuation\">(</span><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">good-enough?</span> guess x<span class=\"token punctuation\">)</span> \n    guess \n    <span class=\"token punctuation\">(</span><span class=\"token function\">sqrt-iter</span> <span class=\"token punctuation\">(</span><span class=\"token function\">improve</span> guess x<span class=\"token punctuation\">)</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Now we need another procedure to improve our guess:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token comment\">;; Reference to the example table.</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">average-of-two</span> x y<span class=\"token punctuation\">)</span> \n  <span class=\"token punctuation\">(</span><span class=\"token operator\">/</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span> x y<span class=\"token punctuation\">)</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  \n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">improve</span> guess x<span class=\"token punctuation\">)</span> \n  <span class=\"token punctuation\">(</span><span class=\"token function\">average-of-two</span> guess <span class=\"token punctuation\">(</span><span class=\"token operator\">/</span> guess x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>The <code class=\"language-text\">good-enough?</code> procedure is a measure of how close the guess is to the square of original number. We can express this as:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token comment\">;; precision is a metric of closeness required for the guess </span>\n<span class=\"token comment\">;; to be the square root of x.</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">good-enough?</span> guess x<span class=\"token punctuation\">)</span> \n  <span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">abs</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token function\">square</span> guess<span class=\"token punctuation\">)</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> &lt;precision><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">square</span> x<span class=\"token punctuation\">)</span> \n  <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span> x x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Finally we can have:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token comment\">;; A default guess of 1.0 is chosen.</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">sqrt</span> x<span class=\"token punctuation\">)</span> \n  <span class=\"token punctuation\">(</span><span class=\"token function\">sqrt-iter</span> <span class=\"token number\">1.0</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>There is some emphasis on being able to express the above without the need of loops, compared to other standard languages.</p>\n<hr>\n<p><strong>Exercise 1.6:</strong> Alyssa P. Hacker doesn’t see why if needs to be provided as a special form. “Why can’t I just define it as an ordinary procedure in terms of cond?” she asks. Alyssa’s friend Eva Lu Ator claims this can indeed be done, and she defines a new version of if:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token comment\">;; Implementing `if` to work using `cond`</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">new-if</span> predicate then-clause else-clause<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token keyword\">cond</span> <span class=\"token punctuation\">(</span><span class=\"token function\">predicate</span> then-clause<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token keyword\">else</span> else-clause<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Eva demonstrates the program for Alyssa:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token comment\">;; Some tests</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">new-if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">=</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token number\">0</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">;;-> 5</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token function\">new-if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token number\">0</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">;; -> 0</span></code></pre></div>\n<p>Delighted, Alyssa uses new-if to rewrite the square-root program:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token comment\">;; The final implementation of sqrt-iter</span>\n<span class=\"token comment\">;; assuming other procedures are same as above.</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">sqrt-iter</span> guess x<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token function\">new-if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">good-enough?</span> guess x<span class=\"token punctuation\">)</span>\n    guess\n    <span class=\"token punctuation\">(</span><span class=\"token function\">sqrt-iter</span> <span class=\"token punctuation\">(</span><span class=\"token function\">improve</span> guess x<span class=\"token punctuation\">)</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>What happens when Alyssa attempts to use this to compute square roots? Explain.</p>\n<p><em>Answer:</em> <code class=\"language-text\">new-if</code> is a <em>procedure</em> and <code class=\"language-text\">if</code> is a <em>special form</em>. That means, the <code class=\"language-text\">sqrt-iter</code> would be evaluated differently.</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token comment\">;; Expanded form </span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">new-if</span> \n  <span class=\"token punctuation\">(</span><span class=\"token function\">good-enough?</span> guess x<span class=\"token punctuation\">)</span> \n    guess \n    <span class=\"token punctuation\">(</span><span class=\"token function\">sqrt-iter</span> <span class=\"token punctuation\">(</span><span class=\"token function\">improve</span> guess x<span class=\"token punctuation\">)</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>We have a problem here, <code class=\"language-text\">if</code> behaves lazily, so it will first evaluate the <em>predicate</em> <code class=\"language-text\">(good-enough? guess x)</code> first and the evaluation of <em>consequent</em> or <em>alternative</em> will be deferred until then.</p>\n<p>Instead of that, we have <code class=\"language-text\">new-if</code> which is a procedure and not a <strong>special-form</strong> causing all the arguments to be evaluated after the operator. This would cause the <code class=\"language-text\">(sqrt-iter (improve guess x) x)</code> to be evaluated irrespective of the output of <code class=\"language-text\">(good-enough)</code> as per the <em>applicative order</em> of procedures, leading to a non-terminating condition.</p>\n<p><code class=\"language-text\">if</code> follows <em>normal order</em> of evaluation and hence, the arguments will be evaluated depending after, and, on the output of the <em>predicate</em>. The stopping condition being <em>predicate</em> returning <code class=\"language-text\">true</code>.</p>","timeToRead":3,"excerpt":"This is a series of posts related to SICP exercises, in continuation of a previous post. The chapters that lead to the exercises are…","frontmatter":{"title":"SICP Exercises 1.6","cover":"https://unsplash.it/1152/300/?random?BirchintheRoses","date":"2020-04-22T00:00:00.000Z","categories":["programming"],"tags":["scheme","drracket","sicp"]},"fields":{"slug":"/sicp-exercises-1-6","date":"April 21, 2020"}}},"pageContext":{"slug":"/sicp-exercises-1-6","nexttitle":"SICP Exercises 1.0 - 1.5","nextslug":"/sicp-exercises-1-0-1-5","prevtitle":"Git log exclude dirs and authors","prevslug":"/git-log-exclude-dirs-and-authors"}}}