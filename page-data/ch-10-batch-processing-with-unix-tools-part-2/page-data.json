{"componentChunkName":"component---src-templates-post-js","path":"/ch-10-batch-processing-with-unix-tools-part-2","result":{"data":{"markdownRemark":{"html":"<h2 id=\"reducing-side-joins-and-grouping\" style=\"position:relative;\"><a href=\"#reducing-side-joins-and-grouping\" aria-label=\"reducing side joins and grouping permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reducing side-joins and grouping</h2>\n<p>In a relational database setting data is usually normalized for faster queries. It is common for a record to have references to other records.\nCoalescing such data is usually achieved by the means of a <code class=\"language-text\">JOIN</code> operation. Another alternative is to denormalize data. </p>\n<p>It can be expected that a database query is indexed, reducing the time it takes to fetch the records. MapReduce jobs don't have a concept of indexing.\nThis leads to a full table-scan a very costly operation. </p>\n<p>We see a common pattern in data processing:</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">entity</th>\n<th align=\"center\">id</th>\n<th align=\"center\">log</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">user</td>\n<td align=\"center\">105</td>\n<td align=\"center\">clicked button</td>\n</tr>\n<tr>\n<td align=\"center\">user</td>\n<td align=\"center\">296</td>\n<td align=\"center\">viewed profile of 134</td>\n</tr>\n<tr>\n<td align=\"center\">user</td>\n<td align=\"center\">105</td>\n<td align=\"center\">login via email campaign</td>\n</tr>\n<tr>\n<td align=\"center\">user</td>\n<td align=\"center\">101</td>\n<td align=\"center\">changed settings</td>\n</tr>\n<tr>\n<td align=\"center\">user</td>\n<td align=\"center\">800</td>\n<td align=\"center\">searched for keyword</td>\n</tr>\n<tr>\n<td align=\"center\">...</td>\n<td align=\"center\">...</td>\n<td align=\"center\">...</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th align=\"center\">user_id</th>\n<th align=\"center\">email</th>\n<th align=\"center\">date-of-birth</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">101</td>\n<td align=\"center\">beth@foo.com</td>\n<td align=\"center\">1991-05-12</td>\n</tr>\n<tr>\n<td align=\"center\">105</td>\n<td align=\"center\">opa@kor.ea</td>\n<td align=\"center\">1998-10-11</td>\n</tr>\n<tr>\n<td align=\"center\">296</td>\n<td align=\"center\">singh@bar.co.in</td>\n<td align=\"center\">1995-03-23</td>\n</tr>\n<tr>\n<td align=\"center\">800</td>\n<td align=\"center\">potato@onion.gg</td>\n<td align=\"center\">1971-08-07</td>\n</tr>\n<tr>\n<td align=\"center\">...</td>\n<td align=\"center\">...</td>\n<td align=\"center\">...</td>\n</tr>\n</tbody>\n</table>\n<p>To aggregate records we would have to perform a join on the <code class=\"language-text\">user_id</code> field. Joining one by one would reduce the throughput,\ncache efficiency would depend on data distribution, running a large number of these queries in parallel would overwhelm the database.</p>\n<ul>\n<li>To achieve a good throughput the computation should be local to a machine.</li>\n<li>We don't want to query a remote database since the results would be non-deterministic in that case.</li>\n<li>We copy the database (a backup).</li>\n<li>Load it in a distributed file system like HDFS.</li>\n<li>Use <code class=\"language-text\">MapReduce</code> to aggregate the data.</li>\n</ul>","timeToRead":2,"excerpt":"Reducing side-joins and grouping In a relational database setting data is usually normalized for faster queries. It is common for a recordâ€¦","frontmatter":{"title":"Ch-10 Batch Processing With Unix Tools Part 2","cover":"https://picsum.photos/seed/seed_n/1500/300","date":"2021-12-26T00:00:00.000Z","categories":["readings"],"tags":["engineering","designing-data-intensive-applications"]},"fields":{"slug":"/ch-10-batch-processing-with-unix-tools-part-2","date":"December 25, 2021"}}},"pageContext":{"slug":"/ch-10-batch-processing-with-unix-tools-part-2","nexttitle":"Ch-02 The Investor and Inflation","nextslug":"/ch-02-the-investor-and-inflation","prevtitle":"Reanimation","prevslug":"/reanimation"}},"staticQueryHashes":["3969716136"]}