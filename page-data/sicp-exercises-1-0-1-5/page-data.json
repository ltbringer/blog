{"componentChunkName":"component---src-templates-post-js","path":"/sicp-exercises-1-0-1-5","result":{"data":{"markdownRemark":{"html":"<p>Working out SICP exercises on an Ubuntu-18. I found the most convenient way to get started is installing <code class=\"language-text\">racket</code>. This also installs <code class=\"language-text\">DrRacket</code> an IDE that makes working with <code class=\"language-text\">scheme</code> painless, rather it makes it fun. </p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">$ <span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> racket</code></pre></div>\n<p>Once the installation is out of the way, <code class=\"language-text\">DrRacket</code> is ready to use via the application-search feature or running <code class=\"language-text\">drracket</code> in a terminal shell.</p>\n<p>Having a reference to the <a href=\"https://web.mit.edu/alexmv/6.037/sicp.pdf\">book</a> should help while logging my lessons. I plan on posting covered exercises within the titles, hopefully across editions of the books those don't change. In case they do, the book is here.</p>\n<p>The book talks about these topics before the first set of exercises:</p>\n<ol>\n<li>\n<p>Building Abstractions with Procedures</p>\n<ol>\n<li>\n<p>The elements of programming</p>\n<ol>\n<li>Expressions</li>\n<li>Naming and the Environment</li>\n<li>Evaluating Combinations</li>\n<li>Compound Procedures</li>\n<li>\n<p>The Substitution Model for Procedure Application</p>\n<ul>\n<li>Applicative order vs normal order</li>\n</ul>\n</li>\n<li>Conditional Expressions and Predicates</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"applicative-order-vs-normal-order\" style=\"position:relative;\"><a href=\"#applicative-order-vs-normal-order\" aria-label=\"applicative order vs normal order permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Applicative order vs Normal order</h2>\n<p>Going through the topics, I found myself familiar to most topics albeit a different name or no name at all, but <em>Applicative order vs normal order</em> (1.1.5) seemed to be something that\nI had taken for granted. I had assumed programming languages would <del>obviously</del> implement the <em>applicative order</em>. The difference in working is covered by these examples:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token comment\">;; applicative order:-</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">sum-of-squares</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span> <span class=\"token number\">5</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span> <span class=\"token number\">5</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">;; Evaluate operateor and arguments first</span>\n<span class=\"token comment\">;; (sum-of-squares 6 10)</span>\n<span class=\"token comment\">;; (+ (square 6) (square 10))</span></code></pre></div>\n<p>on the contrary, the <em>normal order</em> works this way:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token comment\">;; normal order</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">sum-of-squares</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span> <span class=\"token number\">5</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span> <span class=\"token number\">5</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">;; Expand the expressions first</span>\n<span class=\"token comment\">;; (sum-of-squares (+ 5 1) (* 5 2))</span>\n<span class=\"token comment\">;; (+ (square (+ 5 1)) (square (* 5 2)))</span>\n<span class=\"token comment\">;; (+ (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2)))</span></code></pre></div>\n<p>I don't understand why is the <em>normal order</em> considered <em>normal</em>, it returns the same result but slower (The need to compute terms like <code class=\"language-text\">(+ 5 1)</code> and so on twice!).</p>\n<h2 id=\"conditional-expressions-and-predicates\" style=\"position:relative;\"><a href=\"#conditional-expressions-and-predicates\" aria-label=\"conditional expressions and predicates permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conditional Expressions and Predicates</h2>\n<h3 id=\"cond\" style=\"position:relative;\"><a href=\"#cond\" aria-label=\"cond permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Cond</h3>\n<p>Using this snippet for reference.</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">abs</span> x<span class=\"token punctuation\">)</span>          <span class=\"token comment\">;; Cond contains clauses, the first expression in each clause is a predictate</span>\n  <span class=\"token punctuation\">(</span><span class=\"token keyword\">cond</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token function\">x</span> > <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> x<span class=\"token punctuation\">)</span>      <span class=\"token comment\">;; p1 (predicate = (x > 0))</span>\n        <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token function\">x</span> &lt; <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">-</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">;; p2</span>\n        <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token operator\">=</span> x <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>    <span class=\"token comment\">;; p3</span></code></pre></div>\n<p>The expression is evaluated as follows:</p>\n<p><code class=\"language-text\">p1</code> is evaluated first, if the value is false:</p>\n<ol>\n<li><code class=\"language-text\">p2</code> is evaluated, else.</li>\n<li>Since <code class=\"language-text\">p1</code> returned <code class=\"language-text\">true</code>, the <em>consequent expression</em> is evaluated and returned.</li>\n<li>If <code class=\"language-text\">pN</code> happens to be <code class=\"language-text\">false</code>, the other <em>predicates</em> get tested until one that returns <code class=\"language-text\">true</code>.</li>\n<li>If none of the predicates evaluate to <code class=\"language-text\">true</code>, the value evaluated by <code class=\"language-text\">cond</code> is <code class=\"language-text\">undefined</code>.</li>\n<li>You can have <code class=\"language-text\">else</code> as the last predicate instead of managing the behaviour in [4].</li>\n</ol>\n<h3 id=\"if\" style=\"position:relative;\"><a href=\"#if\" aria-label=\"if permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>If</h3>\n<p>The same function above could be re-written as:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">abs</span> x<span class=\"token punctuation\">)</span> \n  <span class=\"token punctuation\">(</span><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span> x <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> \n      <span class=\"token punctuation\">(</span><span class=\"token operator\">-</span> x<span class=\"token punctuation\">)</span> \n      x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      \n<span class=\"token comment\">;; (if &lt;predicate> &lt;consequent> &lt;alternative>)</span></code></pre></div>\n<p><em>if</em> is a restricted conditional (at least for scheme) used when there are precisely two cases. The evaluation works like:</p>\n<ol>\n<li>The interpreter starts by evaluating the <em>predicate</em>, if <code class=\"language-text\">true</code>.</li>\n<li>The interpreter evaluates the consequent.</li>\n<li>Otherwise evaluates the alternative.</li>\n<li>Return's either [2] or [3] as applicable.</li>\n<li>Logical predicates like <code class=\"language-text\">and</code>, <code class=\"language-text\">or</code>, <code class=\"language-text\">not</code> are available for use in <code class=\"language-text\">if</code>.</li>\n</ol>\n<p>Note: <code class=\"language-text\">and</code> and <code class=\"language-text\">or</code> are special forms, they are not procedures so they don't follow the general _applicative order</p>\n<p>Skipped exercises: 1.1, 1.2</p>\n<p><strong>Exercise 1.3:</strong> Define a procedure that takes three numbers as arguments and returns the sum of the squares of the two larger numbers.</p>\n<p><em>Answer</em>:</p>\n<iframe height=\"600px\" width=\"100%\" src=\"https://repl.it/@amreshvenugopal/sicp13?lite=true\" frameborder=\"no\"></iframe>\n<hr>\n<p><strong>Exercise 1.4:</strong> Observe that our model of evaluation allows for combinations whose operators are compound expressions. Use this observation to\ndescribe the behaviour of the following procedure.</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">a-plus-abs-b</span> a b<span class=\"token punctuation\">)</span> \n  <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">></span> b <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> + -<span class=\"token punctuation\">)</span> a b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><em>Answer</em>: The <code class=\"language-text\">if</code> conditional will supply the operator, either <code class=\"language-text\">+</code> or <code class=\"language-text\">-</code>. Since the <em>predicate</em> is evaluated first.</p>\n<hr>\n<p><strong>Exercise 1.5:</strong> Ben Bitdiddle has invented a test to determine whether the interpreter he is faced with is using <em>applicative-order</em> evaluation or <em>normal-order</em> evaluation.\nHe defines the following two procedures:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token comment\">;; -</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">p</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token function\">p</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">test</span> x y<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">=</span> x <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token number\">0</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>and then he evaluates the expression.</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token function\">test</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">(</span><span class=\"token function\">p</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<ol>\n<li>What behavior will Ben observe with an interpreter that uses applicative-order evaluation? </li>\n<li>What behavior will he observe with an interpreter that uses normal-order evaluation? </li>\n</ol>\n<p>Explain your answer. (Assume that the evaluation rule for the special form if is the same whether the interpreter is using normal or applicative order:\nThe predicate expression is evaluated first, and the result determines whether to evaluate the consequent or the alternative expression.)</p>\n<p><em>Answer</em>: The procedure is a recursive call with no stopping criteria, so the evaluation should halt the execution if the procedure is invoked.</p>\n<ol>\n<li>\n<p><em>Normal order</em>:</p>\n<ol>\n<li><code class=\"language-text\"></code>(test 0 (p))<code class=\"language-text\">will be expanded first to</code>(if (= 0 0) 0 (p))`</li>\n<li>The <code class=\"language-text\">if</code> special-form will evaluate the <em>predicate</em>, and return the consequent which is 0.\nThe <em>alternative</em> will not be evaluated.</li>\n</ol>\n</li>\n<li><em>Applicative order</em>: Since the procedure <code class=\"language-text\">(test 0 (p))</code> requires <code class=\"language-text\">(p)</code> to be evaluated, the test will never complete.</li>\n</ol>\n<hr>","timeToRead":4,"excerpt":"Working out SICP exercises on an Ubuntu-18. I found the most convenient way to get started is installing . This also installs  an IDE that…","frontmatter":{"title":"SICP Exercises 1.0 - 1.5","cover":"https://unsplash.it/1152/300/?random?BirchintheRoses","date":"2020-04-21T00:00:00.000Z","categories":["programming"],"tags":["scheme","drracket","sicp"]},"fields":{"slug":"/sicp-exercises-1-0-1-5","date":"April 20, 2020"}}},"pageContext":{"slug":"/sicp-exercises-1-0-1-5","nexttitle":"Reanimation","nextslug":"/reanimation","prevtitle":"Negative labels for classification","prevslug":"/negative-labels-for-classification"}}}